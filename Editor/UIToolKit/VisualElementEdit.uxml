<ui:UXML xmlns:ui="UnityEngine.UIElements" xmlns:uie="UnityEditor.UIElements" editor-extension-mode="False">
    <ui:VisualElement name="VisualElement" style="flex-grow: 1; margin-left: 5px; margin-right: 5px; margin-top: 5px; margin-bottom: 5px; padding-left: 6px; padding-right: 6px; padding-top: 6px; padding-bottom: 6px; border-left-width: 2px; border-right-width: 2px; border-top-width: 2px; border-bottom-width: 2px; border-top-left-radius: 15px; border-bottom-left-radius: 15px; border-top-right-radius: 15px; border-bottom-right-radius: 15px; border-left-color: rgb(18, 152, 5); border-right-color: rgb(18, 152, 5); border-top-color: rgb(18, 152, 5); border-bottom-color: rgb(18, 152, 5); background-color: rgba(29, 103, 53, 255);">
        <ui:TextField picking-mode="Ignore" value="filler text" text="filler text" name="tfLable" style="flex-wrap: wrap; white-space: normal;" />
        <ui:TextField picking-mode="Ignore" value="VisualElements specify a contentContainer, ie where children added to their hierarchy will go. In most VisualElements, contentContaienr == this. In the case of the ScrollView however, its contentContainer points to one of its child (which is not the contentViewport).  In short, ScrollView does the abstraction for you and _stepBuilder.Add() will add elements to the right place. In a case where you need to access the real non-abstracted children, you can do _stepBuilder.hierarchy.Add() and this will physically add the VisualElement as a direct child of the ScrollView instead of its container." text="filler text" name="tfBody" style="flex-wrap: wrap; white-space: normal;" />
    </ui:VisualElement>
</ui:UXML>
